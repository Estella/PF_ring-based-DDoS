<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>TommyDS</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="tommy.css" rel="stylesheet" type="text/css">
</head>
<body>

<!-- Generated by Doxygen 1.7.3 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Tommy Benchmarks </h1>  </div>
</div>
<div class="contents">
<div class="textblock"><p>To evaluate Tommy performances, an extensive benchmark was done, comparing it to the best hashtable and trie libraries available.</p>
<h2><a class="anchor" id="thebenchmark"></a>
The Benchmark</h2>
<p>The benchmark consists in storing a set of N pointers to objects and searching them using an integer key.</p>
<p>It's different than the simpler case of mapping integers to integers, as pointers to objects are also dereferenced resulting in additional cache misses. This benchmark favorites implementations that store information in the objects itself, as the additional cache misses are already implicit.</p>
<p>The test dones are:</p>
<ul>
<li><b>Insert</b> Insert all the objects starting with an empty container.</li>
<li><b>Hit</b> Find with success all the objects and derefence them.</li>
<li><b>Miss</b> Find with failure all the objects.</li>
<li><b>Change</b> Find and remove one object and reinsert it with a different key, repeated for all the objects.</li>
<li><b>Remove</b> Remove all the objects end dereference them.</li>
</ul>
<p>The <em>Hit</em>, <em>Miss</em> and <em>Change</em> tests operate always with N objects in the containers. The <em>Insert</em> test starts with an empty container, and the <em>Remove</em> test ends with an empty container. The objects are always deferenced, as we are supposing to use them. This happens even in the remove case, as we are supposing to deallocate them.</p>
<p>The tests are repeated using keys in <em>Random</em> order and then in <em>Forward</em> order. The random order favorites hashtables, as the hash function already randomizes the key. The forward order favorites tries and trees as they use the key directly and they have a cache advantage on using consecutive keys. Usually real uses case are in between, where the random one is the worst case.</p>
<p>All the objects are preallocated in the heap, and this allocation time is not included in the test.</p>
<p>The objects contain an integer <em>value</em> field used for consistency checks, an unused <em>payload</em> field of 16 bytes, and any other data required by the data structure.</p>
<p>The objects are identified and stored using integers and unique <em>keys</em>. The key domain used is <b>dense</b>, and it's defined by the set of N even numbers starting from 0x80000000 to 0x80000000+2*N.</p>
<p>The use of even numbers allows to have missing numbers inside the domain for the <em>Miss</em> and <em>Change</em> tests. Using missing numbers at the corners of the domain would have favorited tries and trees as they implicitely keep track of the maximum and minimum value inserted.</p>
<p>The use of the 0x80000000 base, allow to test a key domain not necessarily starting at 0. Using a 0 base would have favorited some tries managing it as a special case.</p>
<p>The following data structures are tested:</p>
<ul>
<li><a class="el" href="tommyhashtbl_8h.html#a506978bdee7fd24f76a0ba7547206513" title="Fixed size chained hashtable.">tommy_hashtable</a> - Fixed size chained hashtable.</li>
<li><a class="el" href="tommyhashdyn_8h.html#a00c8b944d273f38f9eef91417a1e8991" title="Dynamic chained hashtable.">tommy_hashdyn</a> - Dynamic chained hashtable.</li>
<li><a class="el" href="tommyhashlin_8h.html#ad910f88af8bcd013a8e3cd30d528b904" title="Linear chained hashtable.">tommy_hashlin</a> - Linear chained hashtable.</li>
<li><a class="el" href="tommytrie_8h.html#a05c17b0ace098768808aa9effcaa9559" title="Trie optimized for cache utilization.">tommy_trie</a> - Trie optimized for cache usage.</li>
<li><a class="el" href="tommytrieinp_8h.html#aa375bb131f3d221a24774aef08b27a0a" title="Inplace trie.">tommy_trie_inplace</a> - Trie completely inplace.</li>
<li><a href="http://www.canonware.com/rb/">rbtree</a> - Red-black tree by Jason Evans.</li>
<li><a href="http://attractivechaos.awardspace.com/">khash</a> - Dynamic open addressing hashtable by Attractive Chaos.</li>
<li><a href="http://code.google.com/p/google-sparsehash/">goodledensehash</a> - Dynamic open addressing hashtable by Craig Silverstein at Google.</li>
<li><a href="http://uthash.sourceforge.net/">uthash</a> - Dynamic chaining hashtable by Troy D. Hanson.</li>
<li><a href="http://judy.sourceforge.net/">judy</a> - Burst trie (JudyL) by Doug Baskins at HP.</li>
<li><a href="http://www.nedprod.com/programs/portable/nedtries/">nedtrie</a> - Binary trie inplace by Niall Douglas.</li>
</ul>
<h2><a class="anchor" id="result"></a>
Results</h2>
<p>The most significative tests depend on your data usage model, but if in doubt, you should mostly look at <em>Random Hit</em> and <em>Random Change</em>.</p>
<p>They are valuated the most significatives, because operating always with N elements in the data structure and with a random pattern, they mostly mimic real conditions.</p>
<div align="center">
<img src="def/img_random_hit.png" alt="img_random_hit.png"/>
</div>
<p>In the <em>Random Hit</em> graph you can see a vertical split at the 100.000 elements limit. Before this limit the cache of modern processor is able to contains most of the data, and it allow a very fast access with the most of data structure. After this limit, the number of cache misses is the dominant factor, and the curve depends mainly on the number of cache miss required to reach the object.</p>
<p>For rbtree and nedtrie, it's log2(N) as they have two branches on each node, log4(N) for <a class="el" href="tommytrieinp_8h.html#aa375bb131f3d221a24774aef08b27a0a" title="Inplace trie.">tommy_trie_inplace</a>, log8(N) for <a class="el" href="tommytrie_8h.html#a05c17b0ace098768808aa9effcaa9559" title="Trie optimized for cache utilization.">tommy_trie</a> and 1 for hashtables. For <a class="el" href="tommytrieinp_8h.html#aa375bb131f3d221a24774aef08b27a0a" title="Inplace trie.">tommy_trie_inplace</a> and <a class="el" href="tommytrie_8h.html#a05c17b0ace098768808aa9effcaa9559" title="Trie optimized for cache utilization.">tommy_trie</a> you can change the slope configuring a different number of branches for node.</p>
<div align="center">
<img src="def/img_random_change.png" alt="img_random_change.png"/>
</div>
<p>The <em>Random Change</em> graph confirms the vertical split at the 100.000 elements limit. It also show that hashtables are almost unbeatable with a random access.</p>
<h2><a class="anchor" id="random"></a>
Random order</h2>
<p>Here you can see the whole <em>Random</em> test results in different platforms.</p>
<p>In <em>Random</em> tests hashtables are almost always winning, seconds are tries, and as last trees.</p>
<p>The best choices are <a class="el" href="tommyhashlin_8h.html#ad910f88af8bcd013a8e3cd30d528b904" title="Linear chained hashtable.">tommy_hashlin</a>, and goodledensehash, with <a class="el" href="tommyhashlin_8h.html#ad910f88af8bcd013a8e3cd30d528b904" title="Linear chained hashtable.">tommy_hashlin</a> having the advantage to be real-time friendly and not increasing the heap fragmentation. </p>
<table  border="0">
<tr>
<td><div align="center">
<img src="core_i5_650_3G2/img_random_insert.png" alt="img_random_insert.png"/>
</div>
 </td><td><div align="center">
<img src="core_2_duo_e6600_2G4/img_random_insert.png" alt="img_random_insert.png"/>
</div>
 </td><td><div align="center">
<img src="xeon_e5430_2G6_64/img_random_insert.png" alt="img_random_insert.png"/>
</div>
 </td></tr>
<tr>
<td><div align="center">
<img src="core_i5_650_3G2/img_random_hit.png" alt="img_random_hit.png"/>
</div>
 </td><td><div align="center">
<img src="core_2_duo_e6600_2G4/img_random_hit.png" alt="img_random_hit.png"/>
</div>
 </td><td><div align="center">
<img src="xeon_e5430_2G6_64/img_random_hit.png" alt="img_random_hit.png"/>
</div>
 </td></tr>
<tr>
<td><div align="center">
<img src="core_i5_650_3G2/img_random_miss.png" alt="img_random_miss.png"/>
</div>
 </td><td><div align="center">
<img src="core_2_duo_e6600_2G4/img_random_miss.png" alt="img_random_miss.png"/>
</div>
 </td><td><div align="center">
<img src="xeon_e5430_2G6_64/img_random_miss.png" alt="img_random_miss.png"/>
</div>
 </td></tr>
<tr>
<td><div align="center">
<img src="core_i5_650_3G2/img_random_change.png" alt="img_random_change.png"/>
</div>
 </td><td><div align="center">
<img src="core_2_duo_e6600_2G4/img_random_change.png" alt="img_random_change.png"/>
</div>
 </td><td><div align="center">
<img src="xeon_e5430_2G6_64/img_random_change.png" alt="img_random_change.png"/>
</div>
 </td></tr>
<tr>
<td><div align="center">
<img src="core_i5_650_3G2/img_random_remove.png" alt="img_random_remove.png"/>
</div>
 </td><td><div align="center">
<img src="core_2_duo_e6600_2G4/img_random_remove.png" alt="img_random_remove.png"/>
</div>
 </td><td><div align="center">
<img src="xeon_e5430_2G6_64/img_random_remove.png" alt="img_random_remove.png"/>
</div>
  </td></tr>
</table>
<h2><a class="anchor" id="forward"></a>
Forward order</h2>
<p>Here you can see the whole <em>Forward</em> tests results in different platforms.</p>
<p>In <em>Forward</em> tests tries are the winners. Hashtables are competitive until the cache limit, then they lose against tries. Trees are the slowest.</p>
<p>The best choices are <a class="el" href="tommytrie_8h.html#a05c17b0ace098768808aa9effcaa9559" title="Trie optimized for cache utilization.">tommy_trie</a> and <a class="el" href="tommytrieinp_8h.html#aa375bb131f3d221a24774aef08b27a0a" title="Inplace trie.">tommy_trie_inplace</a>, where <a class="el" href="tommytrie_8h.html#a05c17b0ace098768808aa9effcaa9559" title="Trie optimized for cache utilization.">tommy_trie</a> is a bit faster, and <a class="el" href="tommytrieinp_8h.html#aa375bb131f3d221a24774aef08b27a0a" title="Inplace trie.">tommy_trie_inplace</a> doesn't require a custom allocator.</p>
<p>Note that also hashtables are faster in forward order than random. This may seem a bit surprising as the hash function randomizes the access even with consecutive keys. This happens because the objects are allocated in consecutive memory, and accessing them in order, improves the cache utilization, even if the hashed key is random.</p>
<p>Note also that you can easily get hashtables to reach tries performance tweaking the hash function to put near keys accessed nearby. For example, in the benchmark use something like: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #define hash(v) tommy_inthash32(v &amp; ~0xF) + (v &amp; 0xF)</span>
</pre></div><table  border="0">
<tr>
<td><div align="center">
<img src="core_i5_650_3G2/img_forward_insert.png" alt="img_forward_insert.png"/>
</div>
 </td><td><div align="center">
<img src="core_2_duo_e6600_2G4/img_forward_insert.png" alt="img_forward_insert.png"/>
</div>
 </td><td><div align="center">
<img src="xeon_e5430_2G6_64/img_forward_insert.png" alt="img_forward_insert.png"/>
</div>
 </td></tr>
<tr>
<td><div align="center">
<img src="core_i5_650_3G2/img_forward_hit.png" alt="img_forward_hit.png"/>
</div>
 </td><td><div align="center">
<img src="core_2_duo_e6600_2G4/img_forward_hit.png" alt="img_forward_hit.png"/>
</div>
 </td><td><div align="center">
<img src="xeon_e5430_2G6_64/img_forward_hit.png" alt="img_forward_hit.png"/>
</div>
 </td></tr>
<tr>
<td><div align="center">
<img src="core_i5_650_3G2/img_forward_miss.png" alt="img_forward_miss.png"/>
</div>
 </td><td><div align="center">
<img src="core_2_duo_e6600_2G4/img_forward_miss.png" alt="img_forward_miss.png"/>
</div>
 </td><td><div align="center">
<img src="xeon_e5430_2G6_64/img_forward_miss.png" alt="img_forward_miss.png"/>
</div>
 </td></tr>
<tr>
<td><div align="center">
<img src="core_i5_650_3G2/img_forward_change.png" alt="img_forward_change.png"/>
</div>
 </td><td><div align="center">
<img src="core_2_duo_e6600_2G4/img_forward_change.png" alt="img_forward_change.png"/>
</div>
 </td><td><div align="center">
<img src="xeon_e5430_2G6_64/img_forward_change.png" alt="img_forward_change.png"/>
</div>
 </td></tr>
<tr>
<td><div align="center">
<img src="core_i5_650_3G2/img_forward_remove.png" alt="img_forward_remove.png"/>
</div>
 </td><td><div align="center">
<img src="core_2_duo_e6600_2G4/img_forward_remove.png" alt="img_forward_remove.png"/>
</div>
 </td><td><div align="center">
<img src="xeon_e5430_2G6_64/img_forward_remove.png" alt="img_forward_remove.png"/>
</div>
  </td></tr>
</table>
<h2><a class="anchor" id="size"></a>
Size</h2>
<p>Here you can see the memory usage of the different data structures. </p>
<table  border="0">
<tr>
<td><div align="center">
<img src="core_i5_650_3G2/img_random_size.png" alt="img_random_size.png"/>
</div>
 </td><td><div align="center">
<img src="core_2_duo_e6600_2G4/img_random_size.png" alt="img_random_size.png"/>
</div>
 </td><td><div align="center">
<img src="xeon_e5430_2G6_64/img_random_size.png" alt="img_random_size.png"/>
</div>
  </td></tr>
</table>
<h2><a class="anchor" id="others"></a>
Other benchmarks</h2>
<p>Here some links to other performance comparison:</p>
<p><a href="http://attractivechaos.wordpress.com/2008/08/28/comparison-of-hash-table-libraries/">Comparison of Hash Table Libraries</a></p>
<p><a href="http://incise.org/hash-table-benchmarks.html">Hash Table Benchmarks</a></p>
<h2><a class="anchor" id="notes"></a>
Notes</h2>
<p>Here some notes about the data structure tested not part of Tommy.</p>
<h3><a class="anchor" id="cgoogledensehash"></a>
Google C sparsehash and densehash</h3>
<p>It's the C implementation located in the experimental/ directory of the googlesparsehash archive. It has very bad performances in the <em>Change</em> test for some N values. See for example this <a href="other/cgoogledensehash_problem.png">graph</a> with a lot of spikes. The C++ version doesn't suffer of this problem.</p>
<h3><a class="anchor" id="googledensehash"></a>
Google C++ densehash</h3>
<p>It doesn't release memory on deletion. To avoid an unfair advantage in the <em>Remove</em> test, we force a periodic resize calling resize(0) after any deallocation. The resize is executed when the load factor is lower than 20%.</p>
<h3><a class="anchor" id="khash"></a>
khash</h3>
<p>It doesn't release memory on deletion. This gives an unfair advantage on the <em>Remove</em> test.</p>
<h3><a class="anchor" id="judy"></a>
Judy</h3>
<p>Sometimes it has bad performances in some specific platform and for some specific input data size. This makes difficult to predict the performance, as it is usually good until you get one of these cases. See for example this <a href="other/judy_problem.png">graph</a> with a big replicable spike at 50.000 elements.</p>
<h3><a class="anchor" id="nedtrie"></a>
nedtrie</h3>
<p>I've found a crash bug when inserting keys with the 0 value. The <a href="https://github.com/ned14/nedtries/commit/21039696f27db4ffac70a82f89dc5d00ae74b332">fix</a> of this issue is now in the nedtries github. We do not use the C++ implementation as it doesn't compile with gcc 4.4.3. </p>
</div></div>
</body>
</html>
